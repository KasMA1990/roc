// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Type_Dict {
    pub f0: u32,
    pub f1: u32,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct RocFn {
    pub args: roc_std::RocList<u32>,
    pub externName: roc_std::RocStr,
    pub functionName: roc_std::RocStr,
    pub lambdaSet: u32,
    pub ret: u32,
    pub isToplevel: bool,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum RocNum {
    Dec = 0,
    F32 = 1,
    F64 = 2,
    I128 = 3,
    I16 = 4,
    I32 = 5,
    I64 = 6,
    I8 = 7,
    U128 = 8,
    U16 = 9,
    U32 = 10,
    U64 = 11,
    U8 = 12,
}

impl core::fmt::Debug for RocNum {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Dec => f.write_str("RocNum::Dec"),
            Self::F32 => f.write_str("RocNum::F32"),
            Self::F64 => f.write_str("RocNum::F64"),
            Self::I128 => f.write_str("RocNum::I128"),
            Self::I16 => f.write_str("RocNum::I16"),
            Self::I32 => f.write_str("RocNum::I32"),
            Self::I64 => f.write_str("RocNum::I64"),
            Self::I8 => f.write_str("RocNum::I8"),
            Self::U128 => f.write_str("RocNum::U128"),
            Self::U16 => f.write_str("RocNum::U16"),
            Self::U32 => f.write_str("RocNum::U32"),
            Self::U64 => f.write_str("RocNum::U64"),
            Self::U8 => f.write_str("RocNum::U8"),
        }
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
pub struct R2 {
    pub getter: roc_std::RocStr,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R1 {
    pub accessors: R2,
    pub id: u32,
    pub name: roc_std::RocStr,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R3 {
    pub id: u32,
    pub name: roc_std::RocStr,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Fields {
    HasClosure = 0,
    HasNoClosure = 1,
}

impl core::fmt::Debug for discriminant_Fields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::HasClosure => f.write_str("discriminant_Fields::HasClosure"),
            Self::HasNoClosure => f.write_str("discriminant_Fields::HasNoClosure"),
        }
    }
}

#[repr(C, align(4))]
pub union union_Fields {
    HasClosure: core::mem::ManuallyDrop<roc_std::RocList<R1>>,
    HasNoClosure: core::mem::ManuallyDrop<roc_std::RocList<R3>>,
}

const _SIZE_CHECK_union_Fields: () = assert!(core::mem::size_of::<union_Fields>() == 12);
const _ALIGN_CHECK_union_Fields: () = assert!(core::mem::align_of::<union_Fields>() == 4);

const _SIZE_CHECK_Fields: () = assert!(core::mem::size_of::<Fields>() == 16);
const _ALIGN_CHECK_Fields: () = assert!(core::mem::align_of::<Fields>() == 4);

impl Fields {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Fields {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Fields>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Fields) {
        let discriminant_ptr: *mut discriminant_Fields = (self as *mut Fields).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Fields {
    payload: union_Fields,
    discriminant: discriminant_Fields,
}

impl Clone for Fields {
    fn clone(&self) -> Self {
        use discriminant_Fields::*;

        let payload = unsafe {
            match self.discriminant {
                HasClosure => union_Fields {
                    HasClosure: self.payload.HasClosure.clone(),
                },
                HasNoClosure => union_Fields {
                    HasNoClosure: self.payload.HasNoClosure.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Fields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Fields::*;

        unsafe {
            match self.discriminant {
                HasClosure => {
                    let field: &roc_std::RocList<R1> = &self.payload.HasClosure;
                    f.debug_tuple("Fields::HasClosure").field(field).finish()
                },
                HasNoClosure => {
                    let field: &roc_std::RocList<R3> = &self.payload.HasNoClosure;
                    f.debug_tuple("Fields::HasNoClosure").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Fields {}

impl PartialEq for Fields {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Fields::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                HasClosure => self.payload.HasClosure == other.payload.HasClosure,
                HasNoClosure => self.payload.HasNoClosure == other.payload.HasNoClosure,
            }
        }
    }
}

impl Ord for Fields {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Fields {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Fields::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    HasClosure => self.payload.HasClosure.partial_cmp(&other.payload.HasClosure),
                    HasNoClosure => self.payload.HasNoClosure.partial_cmp(&other.payload.HasNoClosure),
                }
            },
        }
    }
}

impl core::hash::Hash for Fields {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Fields::*;

        unsafe {
            match self.discriminant {
                HasClosure => self.payload.HasClosure.hash(state),
                HasNoClosure => self.payload.HasNoClosure.hash(state),
            }
        }
    }
}

impl Fields {

    pub fn unwrap_HasClosure(mut self) -> roc_std::RocList<R1> {
        debug_assert_eq!(self.discriminant, discriminant_Fields::HasClosure);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.HasClosure) }
    }

    pub fn is_HasClosure(&self) -> bool {
        matches!(self.discriminant, discriminant_Fields::HasClosure)
    }

    pub fn unwrap_HasNoClosure(mut self) -> roc_std::RocList<R3> {
        debug_assert_eq!(self.discriminant, discriminant_Fields::HasNoClosure);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.HasNoClosure) }
    }

    pub fn is_HasNoClosure(&self) -> bool {
        matches!(self.discriminant, discriminant_Fields::HasNoClosure)
    }
}



impl Fields {

    pub fn HasClosure(payload: roc_std::RocList<R1>) -> Self {
        Self {
            discriminant: discriminant_Fields::HasClosure,
            payload: union_Fields {
                HasClosure: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn HasNoClosure(payload: roc_std::RocList<R3>) -> Self {
        Self {
            discriminant: discriminant_Fields::HasNoClosure,
            payload: union_Fields {
                HasNoClosure: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for Fields {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Fields::HasClosure => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.HasClosure) },
            discriminant_Fields::HasNoClosure => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.HasNoClosure) },
        }
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R4 {
    pub size: u32,
    pub tags: roc_std::RocList<roc_std::RocStr>,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R5 {
    pub payload: u32,
    pub tagName: roc_std::RocStr,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_U1 {
    None = 0,
    Some = 1,
}

impl core::fmt::Debug for discriminant_U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_U1::None"),
            Self::Some => f.write_str("discriminant_U1::Some"),
        }
    }
}

#[repr(C, align(4))]
pub union union_U1 {
    Some: u32,
}

const _SIZE_CHECK_union_U1: () = assert!(core::mem::size_of::<union_U1>() == 4);
const _ALIGN_CHECK_union_U1: () = assert!(core::mem::align_of::<union_U1>() == 4);

const _SIZE_CHECK_U1: () = assert!(core::mem::size_of::<U1>() == 8);
const _ALIGN_CHECK_U1: () = assert!(core::mem::align_of::<U1>() == 4);

impl U1 {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(4))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct U1 {
    payload: union_U1,
    discriminant: discriminant_U1,
}

impl Clone for U1 {
    fn clone(&self) -> Self {
        use discriminant_U1::*;

        let payload = unsafe {
            match self.discriminant {
                None => union_U1 {
                    None: self.payload.None.clone(),
                },
                Some => union_U1 {
                    Some: self.payload.Some.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_U1::*;

        unsafe {
            match self.discriminant {
                Some => {
                    let field: &u32 = &self.payload.Some;
                    f.debug_tuple("U1::Some").field(field).finish()
                },
            }
        }
    }
}

impl Eq for U1 {}

impl PartialEq for U1 {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_U1::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                None => self.payload.None == other.payload.None,
                Some => self.payload.Some == other.payload.Some,
            }
        }
    }
}

impl Ord for U1 {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for U1 {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_U1::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    None => self.payload.None.partial_cmp(&other.payload.None),
                    Some => self.payload.Some.partial_cmp(&other.payload.Some),
                }
            },
        }
    }
}

impl core::hash::Hash for U1 {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_U1::*;

        unsafe {
            match self.discriminant {
                None => self.payload.None.hash(state),
                Some => self.payload.Some.hash(state),
            }
        }
    }
}

impl U1 {

    pub fn is_None(&self) -> bool {
        matches!(self.discriminant, discriminant_U1::None)
    }

    pub fn unwrap_Some(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_U1::Some);
        unsafe { self.payload.Some }
    }

    pub fn is_Some(&self) -> bool {
        matches!(self.discriminant, discriminant_U1::Some)
    }
}



impl U1 {

    pub fn None() -> Self {
        Self {
            discriminant: discriminant_U1::None,
            payload: union_U1 {
                None: (),
            }
        }
    }

    pub fn Some(payload: u32) -> Self {
        Self {
            discriminant: discriminant_U1::Some,
            payload: union_U1 {
                Some: payload,
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R7 {
    pub name: roc_std::RocStr,
    pub payload: U1,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R6 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub tags: roc_std::RocList<R7>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum U2 {
    FirstTagIsNull = 0,
    SecondTagIsNull = 1,
}

impl core::fmt::Debug for U2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FirstTagIsNull => f.write_str("U2::FirstTagIsNull"),
            Self::SecondTagIsNull => f.write_str("U2::SecondTagIsNull"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R8 {
    pub nonNullPayload: u32,
    pub nonNullTag: roc_std::RocStr,
    pub nullTag: roc_std::RocStr,
    pub whichTagIsNull: U2,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R9 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub tags: roc_std::RocList<R7>,
    pub indexOfNullTag: u16,
}

#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
pub struct R15 {
    pub id: u32,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_SingleTagPayload {
    HasClosure = 0,
    HasNoClosure = 1,
}

impl core::fmt::Debug for discriminant_SingleTagPayload {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::HasClosure => f.write_str("discriminant_SingleTagPayload::HasClosure"),
            Self::HasNoClosure => f.write_str("discriminant_SingleTagPayload::HasNoClosure"),
        }
    }
}

#[repr(C, align(4))]
pub union union_SingleTagPayload {
    HasClosure: core::mem::ManuallyDrop<roc_std::RocList<R3>>,
    HasNoClosure: core::mem::ManuallyDrop<roc_std::RocList<R15>>,
}

const _SIZE_CHECK_union_SingleTagPayload: () = assert!(core::mem::size_of::<union_SingleTagPayload>() == 12);
const _ALIGN_CHECK_union_SingleTagPayload: () = assert!(core::mem::align_of::<union_SingleTagPayload>() == 4);

const _SIZE_CHECK_SingleTagPayload: () = assert!(core::mem::size_of::<SingleTagPayload>() == 16);
const _ALIGN_CHECK_SingleTagPayload: () = assert!(core::mem::align_of::<SingleTagPayload>() == 4);

impl SingleTagPayload {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_SingleTagPayload {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_SingleTagPayload>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_SingleTagPayload) {
        let discriminant_ptr: *mut discriminant_SingleTagPayload = (self as *mut SingleTagPayload).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct SingleTagPayload {
    payload: union_SingleTagPayload,
    discriminant: discriminant_SingleTagPayload,
}

impl Clone for SingleTagPayload {
    fn clone(&self) -> Self {
        use discriminant_SingleTagPayload::*;

        let payload = unsafe {
            match self.discriminant {
                HasClosure => union_SingleTagPayload {
                    HasClosure: self.payload.HasClosure.clone(),
                },
                HasNoClosure => union_SingleTagPayload {
                    HasNoClosure: self.payload.HasNoClosure.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for SingleTagPayload {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_SingleTagPayload::*;

        unsafe {
            match self.discriminant {
                HasClosure => {
                    let field: &roc_std::RocList<R3> = &self.payload.HasClosure;
                    f.debug_tuple("SingleTagPayload::HasClosure").field(field).finish()
                },
                HasNoClosure => {
                    let field: &roc_std::RocList<R15> = &self.payload.HasNoClosure;
                    f.debug_tuple("SingleTagPayload::HasNoClosure").field(field).finish()
                },
            }
        }
    }
}

impl Eq for SingleTagPayload {}

impl PartialEq for SingleTagPayload {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_SingleTagPayload::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                HasClosure => self.payload.HasClosure == other.payload.HasClosure,
                HasNoClosure => self.payload.HasNoClosure == other.payload.HasNoClosure,
            }
        }
    }
}

impl Ord for SingleTagPayload {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for SingleTagPayload {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_SingleTagPayload::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    HasClosure => self.payload.HasClosure.partial_cmp(&other.payload.HasClosure),
                    HasNoClosure => self.payload.HasNoClosure.partial_cmp(&other.payload.HasNoClosure),
                }
            },
        }
    }
}

impl core::hash::Hash for SingleTagPayload {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_SingleTagPayload::*;

        unsafe {
            match self.discriminant {
                HasClosure => self.payload.HasClosure.hash(state),
                HasNoClosure => self.payload.HasNoClosure.hash(state),
            }
        }
    }
}

impl SingleTagPayload {

    pub fn unwrap_HasClosure(mut self) -> roc_std::RocList<R3> {
        debug_assert_eq!(self.discriminant, discriminant_SingleTagPayload::HasClosure);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.HasClosure) }
    }

    pub fn is_HasClosure(&self) -> bool {
        matches!(self.discriminant, discriminant_SingleTagPayload::HasClosure)
    }

    pub fn unwrap_HasNoClosure(mut self) -> roc_std::RocList<R15> {
        debug_assert_eq!(self.discriminant, discriminant_SingleTagPayload::HasNoClosure);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.HasNoClosure) }
    }

    pub fn is_HasNoClosure(&self) -> bool {
        matches!(self.discriminant, discriminant_SingleTagPayload::HasNoClosure)
    }
}



impl SingleTagPayload {

    pub fn HasClosure(payload: roc_std::RocList<R3>) -> Self {
        Self {
            discriminant: discriminant_SingleTagPayload::HasClosure,
            payload: union_SingleTagPayload {
                HasClosure: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn HasNoClosure(payload: roc_std::RocList<R15>) -> Self {
        Self {
            discriminant: discriminant_SingleTagPayload::HasNoClosure,
            payload: union_SingleTagPayload {
                HasNoClosure: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for SingleTagPayload {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_SingleTagPayload::HasClosure => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.HasClosure) },
            discriminant_SingleTagPayload::HasNoClosure => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.HasNoClosure) },
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R13 {
    pub payload: SingleTagPayload,
    pub tagName: roc_std::RocStr,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_RocTagUnion {
    Enumeration = 0,
    NonNullableUnwrapped = 1,
    NonRecursive = 2,
    NullableUnwrapped = 3,
    NullableWrapped = 4,
    Recursive = 5,
    SingleTagStruct = 6,
}

impl core::fmt::Debug for discriminant_RocTagUnion {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Enumeration => f.write_str("discriminant_RocTagUnion::Enumeration"),
            Self::NonNullableUnwrapped => f.write_str("discriminant_RocTagUnion::NonNullableUnwrapped"),
            Self::NonRecursive => f.write_str("discriminant_RocTagUnion::NonRecursive"),
            Self::NullableUnwrapped => f.write_str("discriminant_RocTagUnion::NullableUnwrapped"),
            Self::NullableWrapped => f.write_str("discriminant_RocTagUnion::NullableWrapped"),
            Self::Recursive => f.write_str("discriminant_RocTagUnion::Recursive"),
            Self::SingleTagStruct => f.write_str("discriminant_RocTagUnion::SingleTagStruct"),
        }
    }
}

#[repr(C, align(4))]
pub union union_RocTagUnion {
    Enumeration: core::mem::ManuallyDrop<R4>,
    NonNullableUnwrapped: core::mem::ManuallyDrop<R5>,
    NonRecursive: core::mem::ManuallyDrop<R6>,
    NullableUnwrapped: core::mem::ManuallyDrop<R8>,
    NullableWrapped: core::mem::ManuallyDrop<R9>,
    Recursive: core::mem::ManuallyDrop<R6>,
    SingleTagStruct: core::mem::ManuallyDrop<R13>,
}

const _SIZE_CHECK_union_RocTagUnion: () = assert!(core::mem::size_of::<union_RocTagUnion>() == 32);
const _ALIGN_CHECK_union_RocTagUnion: () = assert!(core::mem::align_of::<union_RocTagUnion>() == 4);

const _SIZE_CHECK_RocTagUnion: () = assert!(core::mem::size_of::<RocTagUnion>() == 36);
const _ALIGN_CHECK_RocTagUnion: () = assert!(core::mem::align_of::<RocTagUnion>() == 4);

impl RocTagUnion {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocTagUnion {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocTagUnion>(*bytes.as_ptr().add(32))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocTagUnion) {
        let discriminant_ptr: *mut discriminant_RocTagUnion = (self as *mut RocTagUnion).cast();

        unsafe {
            *(discriminant_ptr.add(32)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct RocTagUnion {
    payload: union_RocTagUnion,
    discriminant: discriminant_RocTagUnion,
}

impl Clone for RocTagUnion {
    fn clone(&self) -> Self {
        use discriminant_RocTagUnion::*;

        let payload = unsafe {
            match self.discriminant {
                Enumeration => union_RocTagUnion {
                    Enumeration: self.payload.Enumeration.clone(),
                },
                NonNullableUnwrapped => union_RocTagUnion {
                    NonNullableUnwrapped: self.payload.NonNullableUnwrapped.clone(),
                },
                NonRecursive => union_RocTagUnion {
                    NonRecursive: self.payload.NonRecursive.clone(),
                },
                NullableUnwrapped => union_RocTagUnion {
                    NullableUnwrapped: self.payload.NullableUnwrapped.clone(),
                },
                NullableWrapped => union_RocTagUnion {
                    NullableWrapped: self.payload.NullableWrapped.clone(),
                },
                Recursive => union_RocTagUnion {
                    Recursive: self.payload.Recursive.clone(),
                },
                SingleTagStruct => union_RocTagUnion {
                    SingleTagStruct: self.payload.SingleTagStruct.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for RocTagUnion {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_RocTagUnion::*;

        unsafe {
            match self.discriminant {
                Enumeration => {
                    let field: &R4 = &self.payload.Enumeration;
                    f.debug_tuple("RocTagUnion::Enumeration").field(field).finish()
                },
                NonNullableUnwrapped => {
                    let field: &R5 = &self.payload.NonNullableUnwrapped;
                    f.debug_tuple("RocTagUnion::NonNullableUnwrapped").field(field).finish()
                },
                NonRecursive => {
                    let field: &R6 = &self.payload.NonRecursive;
                    f.debug_tuple("RocTagUnion::NonRecursive").field(field).finish()
                },
                NullableUnwrapped => {
                    let field: &R8 = &self.payload.NullableUnwrapped;
                    f.debug_tuple("RocTagUnion::NullableUnwrapped").field(field).finish()
                },
                NullableWrapped => {
                    let field: &R9 = &self.payload.NullableWrapped;
                    f.debug_tuple("RocTagUnion::NullableWrapped").field(field).finish()
                },
                Recursive => {
                    let field: &R6 = &self.payload.Recursive;
                    f.debug_tuple("RocTagUnion::Recursive").field(field).finish()
                },
                SingleTagStruct => {
                    let field: &R13 = &self.payload.SingleTagStruct;
                    f.debug_tuple("RocTagUnion::SingleTagStruct").field(field).finish()
                },
            }
        }
    }
}

impl Eq for RocTagUnion {}

impl PartialEq for RocTagUnion {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_RocTagUnion::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Enumeration => self.payload.Enumeration == other.payload.Enumeration,
                NonNullableUnwrapped => self.payload.NonNullableUnwrapped == other.payload.NonNullableUnwrapped,
                NonRecursive => self.payload.NonRecursive == other.payload.NonRecursive,
                NullableUnwrapped => self.payload.NullableUnwrapped == other.payload.NullableUnwrapped,
                NullableWrapped => self.payload.NullableWrapped == other.payload.NullableWrapped,
                Recursive => self.payload.Recursive == other.payload.Recursive,
                SingleTagStruct => self.payload.SingleTagStruct == other.payload.SingleTagStruct,
            }
        }
    }
}

impl Ord for RocTagUnion {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for RocTagUnion {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_RocTagUnion::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Enumeration => self.payload.Enumeration.partial_cmp(&other.payload.Enumeration),
                    NonNullableUnwrapped => self.payload.NonNullableUnwrapped.partial_cmp(&other.payload.NonNullableUnwrapped),
                    NonRecursive => self.payload.NonRecursive.partial_cmp(&other.payload.NonRecursive),
                    NullableUnwrapped => self.payload.NullableUnwrapped.partial_cmp(&other.payload.NullableUnwrapped),
                    NullableWrapped => self.payload.NullableWrapped.partial_cmp(&other.payload.NullableWrapped),
                    Recursive => self.payload.Recursive.partial_cmp(&other.payload.Recursive),
                    SingleTagStruct => self.payload.SingleTagStruct.partial_cmp(&other.payload.SingleTagStruct),
                }
            },
        }
    }
}

impl core::hash::Hash for RocTagUnion {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_RocTagUnion::*;

        unsafe {
            match self.discriminant {
                Enumeration => self.payload.Enumeration.hash(state),
                NonNullableUnwrapped => self.payload.NonNullableUnwrapped.hash(state),
                NonRecursive => self.payload.NonRecursive.hash(state),
                NullableUnwrapped => self.payload.NullableUnwrapped.hash(state),
                NullableWrapped => self.payload.NullableWrapped.hash(state),
                Recursive => self.payload.Recursive.hash(state),
                SingleTagStruct => self.payload.SingleTagStruct.hash(state),
            }
        }
    }
}

impl RocTagUnion {

    pub fn unwrap_Enumeration(mut self) -> R4 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::Enumeration);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Enumeration) }
    }

    pub fn is_Enumeration(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::Enumeration)
    }

    pub fn unwrap_NonNullableUnwrapped(mut self) -> R5 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::NonNullableUnwrapped);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.NonNullableUnwrapped) }
    }

    pub fn is_NonNullableUnwrapped(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::NonNullableUnwrapped)
    }

    pub fn unwrap_NonRecursive(mut self) -> R6 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::NonRecursive);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.NonRecursive) }
    }

    pub fn is_NonRecursive(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::NonRecursive)
    }

    pub fn unwrap_NullableUnwrapped(mut self) -> R8 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::NullableUnwrapped);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.NullableUnwrapped) }
    }

    pub fn is_NullableUnwrapped(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::NullableUnwrapped)
    }

    pub fn unwrap_NullableWrapped(mut self) -> R9 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::NullableWrapped);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.NullableWrapped) }
    }

    pub fn is_NullableWrapped(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::NullableWrapped)
    }

    pub fn unwrap_Recursive(mut self) -> R6 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::Recursive);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Recursive) }
    }

    pub fn is_Recursive(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::Recursive)
    }

    pub fn unwrap_SingleTagStruct(mut self) -> R13 {
        debug_assert_eq!(self.discriminant, discriminant_RocTagUnion::SingleTagStruct);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.SingleTagStruct) }
    }

    pub fn is_SingleTagStruct(&self) -> bool {
        matches!(self.discriminant, discriminant_RocTagUnion::SingleTagStruct)
    }
}



impl RocTagUnion {

    pub fn Enumeration(payload: R4) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::Enumeration,
            payload: union_RocTagUnion {
                Enumeration: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn NonNullableUnwrapped(payload: R5) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::NonNullableUnwrapped,
            payload: union_RocTagUnion {
                NonNullableUnwrapped: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn NonRecursive(payload: R6) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::NonRecursive,
            payload: union_RocTagUnion {
                NonRecursive: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn NullableUnwrapped(payload: R8) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::NullableUnwrapped,
            payload: union_RocTagUnion {
                NullableUnwrapped: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn NullableWrapped(payload: R9) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::NullableWrapped,
            payload: union_RocTagUnion {
                NullableWrapped: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Recursive(payload: R6) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::Recursive,
            payload: union_RocTagUnion {
                Recursive: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn SingleTagStruct(payload: R13) -> Self {
        Self {
            discriminant: discriminant_RocTagUnion::SingleTagStruct,
            payload: union_RocTagUnion {
                SingleTagStruct: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for RocTagUnion {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_RocTagUnion::Enumeration => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Enumeration) },
            discriminant_RocTagUnion::NonNullableUnwrapped => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.NonNullableUnwrapped) },
            discriminant_RocTagUnion::NonRecursive => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.NonRecursive) },
            discriminant_RocTagUnion::NullableUnwrapped => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.NullableUnwrapped) },
            discriminant_RocTagUnion::NullableWrapped => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.NullableWrapped) },
            discriminant_RocTagUnion::Recursive => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Recursive) },
            discriminant_RocTagUnion::SingleTagStruct => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.SingleTagStruct) },
        }
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Type_TypeAlias {
    pub f0: roc_std::RocStr,
    pub f1: u32,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Type {
    Bool = 0,
    Box = 1,
    Dict = 2,
    EmptyTagUnion = 3,
    Function = 4,
    List = 5,
    Num = 6,
    Record = 7,
    RecursivePointer = 8,
    Result = 9,
    Set = 10,
    Str = 11,
    TagUnion = 12,
    TagUnionPayload = 13,
    Tuple = 14,
    TypeAlias = 15,
    Unit = 16,
    Unsized = 17,
}

impl core::fmt::Debug for discriminant_Type {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Bool => f.write_str("discriminant_Type::Bool"),
            Self::Box => f.write_str("discriminant_Type::Box"),
            Self::Dict => f.write_str("discriminant_Type::Dict"),
            Self::EmptyTagUnion => f.write_str("discriminant_Type::EmptyTagUnion"),
            Self::Function => f.write_str("discriminant_Type::Function"),
            Self::List => f.write_str("discriminant_Type::List"),
            Self::Num => f.write_str("discriminant_Type::Num"),
            Self::Record => f.write_str("discriminant_Type::Record"),
            Self::RecursivePointer => f.write_str("discriminant_Type::RecursivePointer"),
            Self::Result => f.write_str("discriminant_Type::Result"),
            Self::Set => f.write_str("discriminant_Type::Set"),
            Self::Str => f.write_str("discriminant_Type::Str"),
            Self::TagUnion => f.write_str("discriminant_Type::TagUnion"),
            Self::TagUnionPayload => f.write_str("discriminant_Type::TagUnionPayload"),
            Self::Tuple => f.write_str("discriminant_Type::Tuple"),
            Self::TypeAlias => f.write_str("discriminant_Type::TypeAlias"),
            Self::Unit => f.write_str("discriminant_Type::Unit"),
            Self::Unsized => f.write_str("discriminant_Type::Unsized"),
        }
    }
}

#[repr(C, align(4))]
pub union union_Type {
    Box: u32,
    Dict: Type_Dict,
    Function: core::mem::ManuallyDrop<RocFn>,
    List: u32,
    Num: RocNum,
    Record: core::mem::ManuallyDrop<Fields>,
    RecursivePointer: u32,
    Result: Type_Dict,
    Set: u32,
    TagUnion: core::mem::ManuallyDrop<RocTagUnion>,
    TagUnionPayload: core::mem::ManuallyDrop<Fields>,
    Tuple: core::mem::ManuallyDrop<Fields>,
    TypeAlias: core::mem::ManuallyDrop<Type_TypeAlias>,
}

const _SIZE_CHECK_union_Type: () = assert!(core::mem::size_of::<union_Type>() == 48);
const _ALIGN_CHECK_union_Type: () = assert!(core::mem::align_of::<union_Type>() == 4);

const _SIZE_CHECK_Type: () = assert!(core::mem::size_of::<Type>() == 52);
const _ALIGN_CHECK_Type: () = assert!(core::mem::align_of::<Type>() == 4);

impl Type {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Type {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Type>(*bytes.as_ptr().add(48))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Type) {
        let discriminant_ptr: *mut discriminant_Type = (self as *mut Type).cast();

        unsafe {
            *(discriminant_ptr.add(48)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Type {
    payload: union_Type,
    discriminant: discriminant_Type,
}

impl Clone for Type {
    fn clone(&self) -> Self {
        use discriminant_Type::*;

        let payload = unsafe {
            match self.discriminant {
                Bool => union_Type {
                    Bool: self.payload.Bool.clone(),
                },
                Box => union_Type {
                    Box: self.payload.Box.clone(),
                },
                Dict => union_Type {
                    Dict: self.payload.Dict.clone(),
                },
                EmptyTagUnion => union_Type {
                    EmptyTagUnion: self.payload.EmptyTagUnion.clone(),
                },
                Function => union_Type {
                    Function: self.payload.Function.clone(),
                },
                List => union_Type {
                    List: self.payload.List.clone(),
                },
                Num => union_Type {
                    Num: self.payload.Num.clone(),
                },
                Record => union_Type {
                    Record: self.payload.Record.clone(),
                },
                RecursivePointer => union_Type {
                    RecursivePointer: self.payload.RecursivePointer.clone(),
                },
                Result => union_Type {
                    Result: self.payload.Result.clone(),
                },
                Set => union_Type {
                    Set: self.payload.Set.clone(),
                },
                Str => union_Type {
                    Str: self.payload.Str.clone(),
                },
                TagUnion => union_Type {
                    TagUnion: self.payload.TagUnion.clone(),
                },
                TagUnionPayload => union_Type {
                    TagUnionPayload: self.payload.TagUnionPayload.clone(),
                },
                Tuple => union_Type {
                    Tuple: self.payload.Tuple.clone(),
                },
                TypeAlias => union_Type {
                    TypeAlias: self.payload.TypeAlias.clone(),
                },
                Unit => union_Type {
                    Unit: self.payload.Unit.clone(),
                },
                Unsized => union_Type {
                    Unsized: self.payload.Unsized.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Type {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Type::*;

        unsafe {
            match self.discriminant {
                Box => {
                    let field: &u32 = &self.payload.Box;
                    f.debug_tuple("Type::Box").field(field).finish()
                },
                Dict => {
                    let field: &Type_Dict = &self.payload.Dict;
                    f.debug_tuple("Type::Dict").field(field).finish()
                },
                Function => {
                    let field: &RocFn = &self.payload.Function;
                    f.debug_tuple("Type::Function").field(field).finish()
                },
                List => {
                    let field: &u32 = &self.payload.List;
                    f.debug_tuple("Type::List").field(field).finish()
                },
                Num => {
                    let field: &RocNum = &self.payload.Num;
                    f.debug_tuple("Type::Num").field(field).finish()
                },
                Record => {
                    let field: &Fields = &self.payload.Record;
                    f.debug_tuple("Type::Record").field(field).finish()
                },
                RecursivePointer => {
                    let field: &u32 = &self.payload.RecursivePointer;
                    f.debug_tuple("Type::RecursivePointer").field(field).finish()
                },
                Result => {
                    let field: &Type_Dict = &self.payload.Result;
                    f.debug_tuple("Type::Result").field(field).finish()
                },
                Set => {
                    let field: &u32 = &self.payload.Set;
                    f.debug_tuple("Type::Set").field(field).finish()
                },
                TagUnion => {
                    let field: &RocTagUnion = &self.payload.TagUnion;
                    f.debug_tuple("Type::TagUnion").field(field).finish()
                },
                TagUnionPayload => {
                    let field: &Fields = &self.payload.TagUnionPayload;
                    f.debug_tuple("Type::TagUnionPayload").field(field).finish()
                },
                Tuple => {
                    let field: &Fields = &self.payload.Tuple;
                    f.debug_tuple("Type::Tuple").field(field).finish()
                },
                TypeAlias => {
                    let field: &Type_TypeAlias = &self.payload.TypeAlias;
                    f.debug_tuple("Type::TypeAlias").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Type {}

impl PartialEq for Type {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Type::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Bool => self.payload.Bool == other.payload.Bool,
                Box => self.payload.Box == other.payload.Box,
                Dict => self.payload.Dict == other.payload.Dict,
                EmptyTagUnion => self.payload.EmptyTagUnion == other.payload.EmptyTagUnion,
                Function => self.payload.Function == other.payload.Function,
                List => self.payload.List == other.payload.List,
                Num => self.payload.Num == other.payload.Num,
                Record => self.payload.Record == other.payload.Record,
                RecursivePointer => self.payload.RecursivePointer == other.payload.RecursivePointer,
                Result => self.payload.Result == other.payload.Result,
                Set => self.payload.Set == other.payload.Set,
                Str => self.payload.Str == other.payload.Str,
                TagUnion => self.payload.TagUnion == other.payload.TagUnion,
                TagUnionPayload => self.payload.TagUnionPayload == other.payload.TagUnionPayload,
                Tuple => self.payload.Tuple == other.payload.Tuple,
                TypeAlias => self.payload.TypeAlias == other.payload.TypeAlias,
                Unit => self.payload.Unit == other.payload.Unit,
                Unsized => self.payload.Unsized == other.payload.Unsized,
            }
        }
    }
}

impl Ord for Type {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Type {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Type::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Bool => self.payload.Bool.partial_cmp(&other.payload.Bool),
                    Box => self.payload.Box.partial_cmp(&other.payload.Box),
                    Dict => self.payload.Dict.partial_cmp(&other.payload.Dict),
                    EmptyTagUnion => self.payload.EmptyTagUnion.partial_cmp(&other.payload.EmptyTagUnion),
                    Function => self.payload.Function.partial_cmp(&other.payload.Function),
                    List => self.payload.List.partial_cmp(&other.payload.List),
                    Num => self.payload.Num.partial_cmp(&other.payload.Num),
                    Record => self.payload.Record.partial_cmp(&other.payload.Record),
                    RecursivePointer => self.payload.RecursivePointer.partial_cmp(&other.payload.RecursivePointer),
                    Result => self.payload.Result.partial_cmp(&other.payload.Result),
                    Set => self.payload.Set.partial_cmp(&other.payload.Set),
                    Str => self.payload.Str.partial_cmp(&other.payload.Str),
                    TagUnion => self.payload.TagUnion.partial_cmp(&other.payload.TagUnion),
                    TagUnionPayload => self.payload.TagUnionPayload.partial_cmp(&other.payload.TagUnionPayload),
                    Tuple => self.payload.Tuple.partial_cmp(&other.payload.Tuple),
                    TypeAlias => self.payload.TypeAlias.partial_cmp(&other.payload.TypeAlias),
                    Unit => self.payload.Unit.partial_cmp(&other.payload.Unit),
                    Unsized => self.payload.Unsized.partial_cmp(&other.payload.Unsized),
                }
            },
        }
    }
}

impl core::hash::Hash for Type {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Type::*;

        unsafe {
            match self.discriminant {
                Bool => self.payload.Bool.hash(state),
                Box => self.payload.Box.hash(state),
                Dict => self.payload.Dict.hash(state),
                EmptyTagUnion => self.payload.EmptyTagUnion.hash(state),
                Function => self.payload.Function.hash(state),
                List => self.payload.List.hash(state),
                Num => self.payload.Num.hash(state),
                Record => self.payload.Record.hash(state),
                RecursivePointer => self.payload.RecursivePointer.hash(state),
                Result => self.payload.Result.hash(state),
                Set => self.payload.Set.hash(state),
                Str => self.payload.Str.hash(state),
                TagUnion => self.payload.TagUnion.hash(state),
                TagUnionPayload => self.payload.TagUnionPayload.hash(state),
                Tuple => self.payload.Tuple.hash(state),
                TypeAlias => self.payload.TypeAlias.hash(state),
                Unit => self.payload.Unit.hash(state),
                Unsized => self.payload.Unsized.hash(state),
            }
        }
    }
}

impl Type {

    pub fn is_Bool(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Bool)
    }

    pub fn unwrap_Box(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_Type::Box);
        unsafe { self.payload.Box }
    }

    pub fn is_Box(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Box)
    }

    pub fn unwrap_Dict(mut self) -> Type_Dict {
        debug_assert_eq!(self.discriminant, discriminant_Type::Dict);
        unsafe { self.payload.Dict }
    }

    pub fn is_Dict(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Dict)
    }

    pub fn is_EmptyTagUnion(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::EmptyTagUnion)
    }

    pub fn unwrap_Function(mut self) -> RocFn {
        debug_assert_eq!(self.discriminant, discriminant_Type::Function);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Function) }
    }

    pub fn is_Function(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Function)
    }

    pub fn unwrap_List(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_Type::List);
        unsafe { self.payload.List }
    }

    pub fn is_List(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::List)
    }

    pub fn unwrap_Num(mut self) -> RocNum {
        debug_assert_eq!(self.discriminant, discriminant_Type::Num);
        unsafe { self.payload.Num }
    }

    pub fn is_Num(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Num)
    }

    pub fn unwrap_Record(mut self) -> Fields {
        debug_assert_eq!(self.discriminant, discriminant_Type::Record);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Record) }
    }

    pub fn is_Record(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Record)
    }

    pub fn unwrap_RecursivePointer(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_Type::RecursivePointer);
        unsafe { self.payload.RecursivePointer }
    }

    pub fn is_RecursivePointer(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::RecursivePointer)
    }

    pub fn unwrap_Result(mut self) -> Type_Dict {
        debug_assert_eq!(self.discriminant, discriminant_Type::Result);
        unsafe { self.payload.Result }
    }

    pub fn is_Result(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Result)
    }

    pub fn unwrap_Set(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_Type::Set);
        unsafe { self.payload.Set }
    }

    pub fn is_Set(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Set)
    }

    pub fn is_Str(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Str)
    }

    pub fn unwrap_TagUnion(mut self) -> RocTagUnion {
        debug_assert_eq!(self.discriminant, discriminant_Type::TagUnion);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.TagUnion) }
    }

    pub fn is_TagUnion(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::TagUnion)
    }

    pub fn unwrap_TagUnionPayload(mut self) -> Fields {
        debug_assert_eq!(self.discriminant, discriminant_Type::TagUnionPayload);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.TagUnionPayload) }
    }

    pub fn is_TagUnionPayload(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::TagUnionPayload)
    }

    pub fn unwrap_Tuple(mut self) -> Fields {
        debug_assert_eq!(self.discriminant, discriminant_Type::Tuple);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Tuple) }
    }

    pub fn is_Tuple(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Tuple)
    }

    pub fn unwrap_TypeAlias(mut self) -> Type_TypeAlias {
        debug_assert_eq!(self.discriminant, discriminant_Type::TypeAlias);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.TypeAlias) }
    }

    pub fn is_TypeAlias(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::TypeAlias)
    }

    pub fn is_Unit(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Unit)
    }

    pub fn is_Unsized(&self) -> bool {
        matches!(self.discriminant, discriminant_Type::Unsized)
    }
}



impl Type {

    pub fn Bool() -> Self {
        Self {
            discriminant: discriminant_Type::Bool,
            payload: union_Type {
                Bool: (),
            }
        }
    }

    pub fn Box(payload: u32) -> Self {
        Self {
            discriminant: discriminant_Type::Box,
            payload: union_Type {
                Box: payload,
            }
        }
    }

    pub fn Dict(payload: Type_Dict) -> Self {
        Self {
            discriminant: discriminant_Type::Dict,
            payload: union_Type {
                Dict: payload,
            }
        }
    }

    pub fn EmptyTagUnion() -> Self {
        Self {
            discriminant: discriminant_Type::EmptyTagUnion,
            payload: union_Type {
                EmptyTagUnion: (),
            }
        }
    }

    pub fn Function(payload: RocFn) -> Self {
        Self {
            discriminant: discriminant_Type::Function,
            payload: union_Type {
                Function: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn List(payload: u32) -> Self {
        Self {
            discriminant: discriminant_Type::List,
            payload: union_Type {
                List: payload,
            }
        }
    }

    pub fn Num(payload: RocNum) -> Self {
        Self {
            discriminant: discriminant_Type::Num,
            payload: union_Type {
                Num: payload,
            }
        }
    }

    pub fn Record(payload: Fields) -> Self {
        Self {
            discriminant: discriminant_Type::Record,
            payload: union_Type {
                Record: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn RecursivePointer(payload: u32) -> Self {
        Self {
            discriminant: discriminant_Type::RecursivePointer,
            payload: union_Type {
                RecursivePointer: payload,
            }
        }
    }

    pub fn Result(payload: Type_Dict) -> Self {
        Self {
            discriminant: discriminant_Type::Result,
            payload: union_Type {
                Result: payload,
            }
        }
    }

    pub fn Set(payload: u32) -> Self {
        Self {
            discriminant: discriminant_Type::Set,
            payload: union_Type {
                Set: payload,
            }
        }
    }

    pub fn Str() -> Self {
        Self {
            discriminant: discriminant_Type::Str,
            payload: union_Type {
                Str: (),
            }
        }
    }

    pub fn TagUnion(payload: RocTagUnion) -> Self {
        Self {
            discriminant: discriminant_Type::TagUnion,
            payload: union_Type {
                TagUnion: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn TagUnionPayload(payload: Fields) -> Self {
        Self {
            discriminant: discriminant_Type::TagUnionPayload,
            payload: union_Type {
                TagUnionPayload: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Tuple(payload: Fields) -> Self {
        Self {
            discriminant: discriminant_Type::Tuple,
            payload: union_Type {
                Tuple: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn TypeAlias(payload: Type_TypeAlias) -> Self {
        Self {
            discriminant: discriminant_Type::TypeAlias,
            payload: union_Type {
                TypeAlias: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Unit() -> Self {
        Self {
            discriminant: discriminant_Type::Unit,
            payload: union_Type {
                Unit: (),
            }
        }
    }

    pub fn Unsized() -> Self {
        Self {
            discriminant: discriminant_Type::Unsized,
            payload: union_Type {
                Unsized: (),
            }
        }
    }
}

impl Drop for Type {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Type::Bool => {}
            discriminant_Type::Box => {}
            discriminant_Type::Dict => {}
            discriminant_Type::EmptyTagUnion => {}
            discriminant_Type::Function => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Function) },
            discriminant_Type::List => {}
            discriminant_Type::Num => {}
            discriminant_Type::Record => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Record) },
            discriminant_Type::RecursivePointer => {}
            discriminant_Type::Result => {}
            discriminant_Type::Set => {}
            discriminant_Type::Str => {}
            discriminant_Type::TagUnion => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.TagUnion) },
            discriminant_Type::TagUnionPayload => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.TagUnionPayload) },
            discriminant_Type::Tuple => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Tuple) },
            discriminant_Type::TypeAlias => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.TypeAlias) },
            discriminant_Type::Unit => {}
            discriminant_Type::Unsized => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum Architecture {
    Aarch32 = 0,
    Aarch64 = 1,
    Wasm32 = 2,
    X86x32 = 3,
    X86x64 = 4,
}

impl core::fmt::Debug for Architecture {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Aarch32 => f.write_str("Architecture::Aarch32"),
            Self::Aarch64 => f.write_str("Architecture::Aarch64"),
            Self::Wasm32 => f.write_str("Architecture::Wasm32"),
            Self::X86x32 => f.write_str("Architecture::X86x32"),
            Self::X86x64 => f.write_str("Architecture::X86x64"),
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum OperatingSystem {
    Unix = 0,
    Wasi = 1,
    Windows = 2,
}

impl core::fmt::Debug for OperatingSystem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Unix => f.write_str("OperatingSystem::Unix"),
            Self::Wasi => f.write_str("OperatingSystem::Wasi"),
            Self::Windows => f.write_str("OperatingSystem::Windows"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Target {
    pub architecture: Architecture,
    pub operatingSystem: OperatingSystem,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Module {
    pub aligns: roc_std::RocList<u32>,
    pub deps: roc_std::RocDict<u32, roc_std::RocList<u32>>,
    pub entrypoints: roc_std::RocDict<roc_std::RocStr, u32>,
    pub name: roc_std::RocStr,
    pub path: roc_std::RocStr,
    pub sizes: roc_std::RocList<u32>,
    pub types: roc_std::RocList<Type>,
    pub typesByName: roc_std::RocDict<roc_std::RocStr, u32>,
    pub target: Target,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct File {
    pub content: roc_std::RocStr,
    pub name: roc_std::RocList<u8>,
}



pub fn makeGlueForHost(arg0: roc_std::RocList<Module>) -> roc_std::RocResult<roc_std::RocList<File>, roc_std::RocStr> {
    extern "C" {
        fn roc__makeGlueForHost_1_exposed_generic(_: *mut roc_std::RocResult<roc_std::RocList<File>, roc_std::RocStr>, _: &mut core::mem::ManuallyDrop<roc_std::RocList<Module>>);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__makeGlueForHost_1_exposed_generic(ret.as_mut_ptr(), &mut core::mem::ManuallyDrop::new(arg0));

        ret.assume_init()
    }
}