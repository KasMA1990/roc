// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Copy, Default, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
pub struct U1 ();

impl U1 {
    /// A tag named Err, which has no payload.
    pub const Err: Self = Self();

    /// Other `into_` methods return a payload, but since Err tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Err(self) {
        ()
    }

    /// Other `as_` methods return a payload, but since Err tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Err(&self) {
        ()
    }
}

impl core::fmt::Debug for U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U1::Err")
    }
}



#[repr(C)]
#[derive(Debug, Clone)]
pub struct RocFunction_68 {
    closure_data: roc_std::RocList<u8>,
}

impl RocFunction_68 {
    pub fn force_thunk(self) -> U1 {
        extern "C" {
            fn roc__mainForHost_0_caller(arg0: *const (), closure_data: *mut u8, output: *mut U1);
        }

        let mut output = core::mem::MaybeUninit::uninit();
        let closure_ptr =
            (&mut core::mem::ManuallyDrop::new(self.closure_data)) as *mut _ as *mut u8;

        unsafe {
            roc__mainForHost_0_caller(&(), closure_ptr, output.as_mut_ptr());

            output.assume_init()
        }
    }
}

pub fn mainForHost(arg0: roc_std::RocStr) -> RocFunction_68 {
    extern "C" {
        fn roc__mainForHost_1_exposed_generic(_: *mut RocFunction_68, _: &mut core::mem::ManuallyDrop<roc_std::RocStr>);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__mainForHost_1_exposed_generic(ret.as_mut_ptr(), &mut core::mem::ManuallyDrop::new(arg0));

        ret.assume_init()
    }
}